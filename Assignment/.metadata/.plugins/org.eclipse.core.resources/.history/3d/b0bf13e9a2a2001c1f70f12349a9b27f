package ass1;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class MParallelSorter1 implements Sorter {

	public static final ExecutorService pool = Executors.newFixedThreadPool(10);
	
	@Override
	public <T extends Comparable<? super T>> List<T> sort(List<T> list){

		// If the size is less the 20 use a sequential algorithm
		if (list.size() < 20) {
			return new MSequentialSorter().sort(list);
		}

		int size = list.size();

		if (size < 2) {
			return list;
		}

		List<T> left = sort(new ArrayList<>(list.subList(0, (size + 1) / 2)));
		List<T> right = sort(new ArrayList<>(list.subList((size + 1) / 2, size)));
		
		List<Future<List<T>>> mergeResults = new ArrayList<>();

		mergeResults.add(pool.submit(() -> merge(left, right)));
		
		try {
			return mergeResults.get(0).get();

		} catch (Throwable e) {
			return null;
		}
		
		
		
	}
	
	
	public <T extends Comparable<? super T>> List<T> merge(List<T> left, List<T> right) {


			ArrayList<T> toReturn = new ArrayList<>();

			int i = 0, j = 0;

			while (i < left.size() && j < right.size()) {
				if (left.get(i).compareTo(right.get(j)) < 0) {
					toReturn.add(left.get(i++));
				} else {
					toReturn.add(right.get(j++));
				}
			}

			while (i < left.size()) {
				toReturn.add(left.get(i++));
			}

			while (j < right.size()) {
				toReturn.add(right.get(j++));
			}

			return toReturn;
		}

}